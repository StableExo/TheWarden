/**
 * Test: Ankr Vulnerability Detector
 * 
 * Validates vulnerability detection logic
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  AnkrVulnerabilityDetector,
  VulnerabilitySeverity,
  TransactionPattern,
} from '../../../src/security/ankr/AnkrVulnerabilityDetector.js';

describe('AnkrVulnerabilityDetector', () => {
  let detector: AnkrVulnerabilityDetector;

  beforeEach(() => {
    detector = new AnkrVulnerabilityDetector();
    detector.clearFindings();
  });

  it('should initialize with zero findings', () => {
    const findings = detector.getFindings();
    expect(findings.length).toBe(0);
  });

  it('should detect DoS pattern on ankrBNB flashUnstake', async () => {
    const tx: TransactionPattern = {
      txHash: '0x123',
      from: '0xabc',
      to: '0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827', // ankrBNB
      value: '0',
      functionSignature: 'flashUnstake(uint256)',
      gasUsed: '650000', // High gas usage
      blockNumber: 12345678,
      timestamp: Date.now(),
    };

    const findings = await detector.analyzeTransaction(tx);
    expect(findings.length).toBeGreaterThan(0);
    expect(findings[0].type).toBe('Flash Unstake Fee DoS');
    expect(findings[0].severity).toBe(VulnerabilitySeverity.HIGH);
  });

  it('should detect zero address validation error', async () => {
    const tx: TransactionPattern = {
      txHash: '0x456',
      from: '0x0000000000000000000000000000000000000000',
      to: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb', // ankrETH
      value: '0',
      functionSignature: 'deposit()',
      gasUsed: '100000',
      blockNumber: 12345679,
      timestamp: Date.now(),
    };

    const findings = await detector.analyzeTransaction(tx);
    const validationFindings = findings.filter(
      (f) => f.type === 'Missing Address Validation'
    );
    expect(validationFindings.length).toBeGreaterThan(0);
  });

  it('should detect privilege escalation attempt', async () => {
    const tx: TransactionPattern = {
      txHash: '0x789',
      from: '0xmalicious',
      to: '0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827', // ankrBNB
      value: '0',
      functionSignature: 'setFee(uint256)',
      gasUsed: '50000',
      blockNumber: 12345680,
      timestamp: Date.now(),
    };

    const findings = await detector.analyzeTransaction(tx);
    const privilegeFindings = findings.filter(
      (f) => f.type === 'Privilege Escalation Attempt'
    );
    expect(privilegeFindings.length).toBeGreaterThan(0);
    expect(privilegeFindings[0].severity).toBe(VulnerabilitySeverity.CRITICAL);
  });

  it('should detect potential re-entrancy on high-value withdrawal', async () => {
    const tx: TransactionPattern = {
      txHash: '0xabc',
      from: '0xuser',
      to: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb', // ankrETH
      value: String(BigInt(100) * BigInt(10 ** 18)), // 100 ETH
      functionSignature: 'withdraw(uint256)',
      gasUsed: '150000',
      blockNumber: 12345681,
      timestamp: Date.now(),
    };

    const findings = await detector.analyzeTransaction(tx);
    const reentrancyFindings = findings.filter(
      (f) => f.type === 'Potential Re-entrancy'
    );
    expect(reentrancyFindings.length).toBeGreaterThan(0);
  });

  it('should detect oracle manipulation risk', async () => {
    const tx: TransactionPattern = {
      txHash: '0xdef',
      from: '0xattacker',
      to: '0x26dcFbFa8Bc267b250432c01C982Eaf81cC5480C', // ankrPOL
      value: '0',
      functionSignature: 'updateOracle(address)',
      gasUsed: '80000',
      blockNumber: 12345682,
      timestamp: Date.now(),
    };

    const findings = await detector.analyzeTransaction(tx);
    const oracleFindings = findings.filter(
      (f) => f.type === 'Oracle Manipulation Risk'
    );
    expect(oracleFindings.length).toBeGreaterThan(0);
  });

  it('should filter findings by severity', async () => {
    // Generate some findings
    await detector.analyzeTransaction({
      txHash: '0x1',
      from: '0x0',
      to: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb',
      value: '0',
      functionSignature: 'test()',
      gasUsed: '50000',
      blockNumber: 1,
      timestamp: Date.now(),
    });

    const criticalFindings = detector.getFindingsBySeverity(VulnerabilitySeverity.CRITICAL);
    criticalFindings.forEach((f) => {
      expect(f.severity).toBe(VulnerabilitySeverity.CRITICAL);
    });
  });

  it('should export findings for submission', async () => {
    // Generate a finding
    await detector.analyzeTransaction({
      txHash: '0x1',
      from: '0x0',
      to: '0xE95A203B1a91a908F9B9CE46459d101078c2c3cb',
      value: '0',
      functionSignature: 'test()',
      gasUsed: '50000',
      blockNumber: 1,
      timestamp: Date.now(),
    });

    const report = detector.exportForSubmission();
    const data = JSON.parse(report);
    expect(data.summary).toBeDefined();
    expect(data.findings).toBeDefined();
    expect(data.generatedAt).toBeDefined();
  });

  it('should ignore transactions to non-Ankr contracts', async () => {
    const tx: TransactionPattern = {
      txHash: '0xrandom',
      from: '0xuser',
      to: '0x1234567890123456789012345678901234567890', // Random contract
      value: '0',
      functionSignature: 'someFunction()',
      gasUsed: '100000',
      blockNumber: 12345683,
      timestamp: Date.now(),
    };

    const findings = await detector.analyzeTransaction(tx);
    expect(findings.length).toBe(0);
  });
});
